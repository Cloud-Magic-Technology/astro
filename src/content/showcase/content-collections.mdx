---
title: "Content Collections Deep Dive"
description: "Learn how Astro's content collections organize and type your content"
order: 2
icon: "ðŸ“š"
---

import Callout from '../../components/mdx/Callout.astro';

# Content Collections

Astro's Content Collections provide a powerful way to organize, validate, and query your content.

## What Are Content Collections?

Content Collections are Astro's built-in solution for managing groups of related content. They provide:

- **Type safety** - Define schemas with Zod
- **Validation** - Catch frontmatter errors at build time
- **Querying** - Filter, sort, and paginate content
- **Relationships** - Reference other collections

<Callout type="tip">
  Content Collections work with Markdown, MDX, JSON, and YAML files.
  You can even create custom loaders for external data sources!
</Callout>

## Defining a Collection

Collections are defined in `src/content.config.ts`:

```typescript
import { defineCollection, z } from 'astro:content';
import { glob } from 'astro/loaders';

const blog = defineCollection({
  loader: glob({ pattern: '**/*.md', base: './src/content/blog' }),
  schema: z.object({
    title: z.string(),
    description: z.string(),
    pubDate: z.coerce.date(),
    tags: z.array(z.string()).default([]),
    draft: z.boolean().default(false),
  }),
});

export const collections = { blog };
```

## Querying Content

Use the `getCollection` helper to fetch content:

```astro
---
import { getCollection } from 'astro:content';

// Get all published blog posts
const posts = await getCollection('blog', ({ data }) => {
  return data.draft !== true;
});

// Sort by date
const sortedPosts = posts.sort((a, b) =>
  b.data.pubDate.valueOf() - a.data.pubDate.valueOf()
);
---

{sortedPosts.map(post => (
  <article>
    <h2>{post.data.title}</h2>
    <time>{post.data.pubDate.toDateString()}</time>
  </article>
))}
```

<Callout type="note">
  The `getCollection` function accepts an optional filter function
  as its second argument. This runs at build time for static sites.
</Callout>

## Advanced Features

### Computed Fields

Add computed fields based on existing data:

```typescript
schema: z.object({
  title: z.string(),
  pubDate: z.coerce.date(),
}).transform((data) => ({
  ...data,
  readingTime: Math.ceil(data.body.length / 1000),
}));
```

### Collection References

Reference entries from other collections:

```typescript
const blog = defineCollection({
  schema: z.object({
    title: z.string(),
    author: reference('authors'), // Reference authors collection
  }),
});
```

### Custom Loaders

Fetch content from external sources:

```typescript
const products = defineCollection({
  loader: async () => {
    const response = await fetch('https://api.store.com/products');
    return response.json();
  },
  schema: z.object({
    id: z.string(),
    name: z.string(),
    price: z.number(),
  }),
});
```

<Callout type="warning">
  Custom loaders run at build time. For dynamic data that changes frequently,
  consider using API routes or server-side rendering instead.
</Callout>

## Why Use Content Collections?

| Feature | Without Collections | With Collections |
|---------|---------------------|------------------|
| Type Safety | Manual typing | Automatic inference |
| Validation | Runtime errors | Build-time errors |
| Querying | Manual file reading | Built-in helpers |
| Organization | Ad-hoc structure | Enforced structure |

Content Collections turn your content into a typed, queryable database that catches errors before they reach production.
